---
title: "Testing model covariates"
author: "Katy Gaythorpe"
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes: 
- \usepackage{placeins}
output: 
  pdf_document:
    df_print: "kable"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

library(pROC)
library(KsetupR)
source('Z:/YellowFeverModelEstimation2019/Functions/data_launch.R')
library(dplyr)
library(magrittr)
library(corrplot)
```

```{r load_data}

Env_Table_path = "../Data/Environment/global_dat"

filename = get_latest_file(path = Env_Table_path, pattern = "dat")

dat = read.csv(filename, stringsAsFactors = FALSE)

dat = adjust_env_dat(dat)

dat %<>% filter(!is.na(precip_mean))
```

```{r fit models}

covar_to_test = names(dat)[9:(ncol(dat))]

covar_to_test = covar_to_test[grep("surv.qual", covar_to_test, invert = TRUE)]

mod = list()
pvalues = rep(NA, length(covar_to_test))
for(i in 1:length(covar_to_test)){
  mod[[i]] = glm( paste0("cases_or_outbreaks~",covar_to_test[i]), 
           data = dat, family=binomial(link="cloglog"))
  
  pvalues[i] = coef(summary(mod[[i]]))[,4]
}

names(pvalues) = covar_to_test

plot(pvalues)

ind_to_keep = which(pvalues < 0.1)

covar_to_test = covar_to_test[ind_to_keep]
```



Look at correlations.

```{r corr}

cor_out = cor(dat[, covar_to_test])

col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582",
                           "#FDDBC7", "#FFFFFF", "#D1E5F0", "#92C5DE",
                           "#4393C3", "#2166AC", "#053061"))

corrplot::corrplot(cor_out, col =  col2(7), diag = FALSE, type = "upper")

```

```{r corr2}

tab_cor = cor(dat$cases_or_outbreaks, dat[, covar_to_test])
corrplot::corrplot(tab_cor)

data.frame(correlation = t(tab_cor))
```

Look at clusters

```{r cluster}

# get clusters where pair-wise correlations are > 0.75

diag(cor_out) = 0

#anything that does not have any correlations higher than 0.75 is a cluster on its own
max_cors = apply(cor_out, 2, max)

clusters = list()
j = 1
for(i in 1:length(max_cors)){
  if(max_cors[i]<0.75){
    clusters[[j]] = names(max_cors)[i]
    j = j+1
  }
}

max_cors = max_cors[max_cors>=0.75]
cor_out_subs = cor_out[rownames(cor_out) %in% names(max_cors), colnames(cor_out) %in% names(max_cors)]

# for each get the correlations that are larger than 0.75 and compare sets
cor_sets = NULL
for(i in 1:nrow(cor_out_subs)){
  cor_sets[[i]] =  stringr::str_sort(c(rownames(cor_out_subs)[i], names(which(cor_out_subs[i, ]>0.75))))
}

cor_sets = cor_sets[!duplicated(cor_sets)]

clusters = c(clusters, cor_sets)

clusters

```

Then we can choose the most correlated element of each cluster.

```{r clust_cor}

tab_cor = as.data.frame(tab_cor)

covar_out = NULL
for(i in 1:length(clusters)){
  covar_out = c(covar_out,
    names( which.max( tab_cor[ names(tab_cor) %in% clusters[[i]] ] ) )
  )
}

covar_out
```